$date
	Thu Apr 19 00:27:19 2018
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module tb_CacheModel $end
$scope module uut $end
$var wire 8 ! address [7:0] $end
$var wire 1 " clk $end
$var wire 1 # l1d_write_en $end
$var wire 1 $ l2_write_en $end
$var wire 1 % mm_read_en $end
$var wire 1 & mm_write_en $end
$var wire 1 ' report $end
$var wire 1 ( rst $end
$var wire 32 ) write_data [31:0] $end
$var wire 1 * write_en $end
$var wire 32 + read_data [31:0] $end
$var wire 32 , mm_read_data [31:0] $end
$var wire 32 - l2_read_data [31:0] $end
$var wire 1 . l2_hit $end
$var wire 32 / l1i_read_data [31:0] $end
$var wire 1 0 l1i_hit $end
$var wire 32 1 l1d_read_data [31:0] $end
$var wire 1 2 l1d_hit $end
$scope module l1dcache $end
$var wire 8 3 address [7:0] $end
$var wire 1 " clk $end
$var wire 1 2 hit $end
$var wire 32 4 read_data [31:0] $end
$var wire 1 ( rst $end
$var wire 32 5 write_data [31:0] $end
$var wire 1 * write_en $end
$var wire 29 6 tag [28:0] $end
$var wire 2 7 index [1:0] $end
$var wire 1 8 block_offset $end
$var integer 32 9 i [31:0] $end
$upscope $end
$scope module l1icache $end
$var wire 8 : address [7:0] $end
$var wire 1 " clk $end
$var wire 1 0 hit $end
$var wire 32 ; read_data [31:0] $end
$var wire 1 ( rst $end
$var wire 32 < write_data [31:0] $end
$var wire 1 * write_en $end
$var wire 29 = tag [28:0] $end
$var wire 2 > index [1:0] $end
$var wire 1 ? block_offset $end
$var integer 32 @ i [31:0] $end
$upscope $end
$scope module l2cache $end
$var wire 8 A address [7:0] $end
$var wire 1 " clk $end
$var wire 1 . hit $end
$var wire 32 B read_data [31:0] $end
$var wire 1 ( rst $end
$var wire 32 C write_data [31:0] $end
$var wire 1 * write_en $end
$var wire 29 D tag [28:0] $end
$var wire 2 E index [1:0] $end
$var wire 1 F block_offset $end
$var integer 32 G i [31:0] $end
$upscope $end
$scope module main_memory $end
$var wire 1 " clock $end
$var wire 8 H readAddress [7:0] $end
$var wire 1 % readEnable $end
$var wire 1 ' report $end
$var wire 1 ( reset $end
$var wire 8 I writeAddress [7:0] $end
$var wire 32 J writeData [31:0] $end
$var wire 1 * writeEnable $end
$var wire 32 K readData [31:0] $end
$var reg 32 L cycles [31:0] $end
$scope begin RAM_WRITE $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module tb_CacheModel $end
$scope module uut $end
$scope module l1dcache $end
$var reg 32 M \cachemem[0] [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module tb_CacheModel $end
$scope module uut $end
$scope module l1dcache $end
$var reg 32 N \cachemem[1] [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx N
bx M
b0 L
b111010010011 K
b101010111100110111101111 J
b100000 I
b100000 H
b100 G
0F
b0 E
b100000xxxxxxxxxxxxxxxxxxxxx D
b101010111100110111101111 C
bx B
b100000 A
b100 @
0?
b0 >
b100000xxxxxxxxxxxxxxxxxxxxx =
b101010111100110111101111 <
bx ;
b100000 :
b100 9
08
b0 7
b100000xxxxxxxxxxxxxxxxxxxxx 6
b101010111100110111101111 5
bx 4
b100000 3
02
bx 1
00
bx /
0.
bx -
b111010010011 ,
b111010010011 +
0*
b101010111100110111101111 )
1(
0'
0&
1%
0$
0#
1"
b100000 !
$end
#1
0"
#2
b100 G
b100 9
b100 @
1"
#3
0"
#4
b100 @
b100 9
b100 G
1"
#5
0"
#6
b100 G
b100 9
b100 @
1"
#7
0"
#8
b100 @
b100 9
b100 G
1"
#9
0"
#10
x.
x2
x0
b1 L
b101010111100110111101111 +
b101010111100110111101111 ,
b101010111100110111101111 K
b101010111100110111101111 -
b101010111100110111101111 B
b101010111100110111101111 M
b101010111100110111101111 1
b101010111100110111101111 4
b101010111100110111101111 /
b101010111100110111101111 ;
1"
1#
1$
1&
1*
0(
#11
0"
#12
b10 L
b101010111100110111101111 M
1"
#13
0"
#14
b11 L
b101010111100110111101111 M
1"
